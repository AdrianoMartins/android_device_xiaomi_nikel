From 6d52874f8444716944dfc6c4dd74dd93b0a2a75d Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Fri, 30 Sep 2016 21:00:47 +0800
Subject: [PATCH] init: HACK re-allow services without selinux contexts defined

Change-Id: I1c83d5fb9b84acb27f705e1b3042b63ff095c7e7
---
 init/init.cpp    | 4 +++-
 init/service.cpp | 2 ++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/init/init.cpp b/init/init.cpp
index 9992b4784..e9da9586d 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -434,6 +434,7 @@ static void selinux_init_all_handles(void)
     sehandle_prop = selinux_android_prop_context_handle();
 }
 
+#if 0
 enum selinux_enforcing_status { SELINUX_PERMISSIVE, SELINUX_ENFORCING };
 
 static selinux_enforcing_status selinux_status_from_cmdline() {
@@ -447,11 +448,12 @@ static selinux_enforcing_status selinux_status_from_cmdline() {
 
     return status;
 }
+#endif
 
 static bool selinux_is_enforcing(void)
 {
     if (ALLOW_PERMISSIVE_SELINUX) {
-        return selinux_status_from_cmdline() == SELINUX_ENFORCING;
+        return false;  // selinux_status_from_cmdline() == SELINUX_ENFORCING;
     }
     return true;
 }
diff --git a/init/service.cpp b/init/service.cpp
index 76e0bc876..812857959 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -371,12 +371,14 @@ bool Service::Start() {
             scon = ret_scon;
             free(ret_scon);
         }
+#if 0
         if (rc == 0 && scon == mycon) {
             ERROR("Service %s does not have a SELinux domain defined.\n", name_.c_str());
             free(mycon);
             free(fcon);
             return false;
         }
+#endif
         free(mycon);
         free(fcon);
         if (rc < 0) {
-- 
2.11.0

From d8c5b473bb055c91bf1b1602df9585e19a6e167b Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Fri, 30 Sep 2016 21:01:05 +0800
Subject: [PATCH] rootdir: HACK enable adbd always

Change-Id: I16a01bd85f9daabeb3bc2b9342c081372a3e7b67
---
 rootdir/init.usb.rc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/rootdir/init.usb.rc b/rootdir/init.usb.rc
index 915d159a5..0666e4d63 100644
--- a/rootdir/init.usb.rc
+++ b/rootdir/init.usb.rc
@@ -15,7 +15,7 @@ on post-fs-data
 service adbd /sbin/adbd --root_seclabel=u:r:su:s0
     class core
     socket adbd stream 660 system system
-    disabled
+    #disabled
     seclabel u:r:adbd:s0
 
 # adbd on at boot in emulator
-- 
2.11.0

From d1d210bedbf4eedfe5d8a82dfe1d446de9ab2350 Mon Sep 17 00:00:00 2001
From: Dmitry Smirnov <divis1969@gmail.com>
Date: Mon, 14 Nov 2016 23:30:38 +0300
Subject: [PATCH] Remove CAP_SYS_NICE from surfaceflinger

This capability causes surfaceflinger to be treated as a secure process
(AT_SECURE) and linker ignores LD_PRELOAD and LD_SHIM_LIBS but we need these!

Change-Id: Ie9451a970bf43ec864b626e4d3e646bd17869c67
---
 libcutils/fs_config.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/libcutils/fs_config.c b/libcutils/fs_config.c
index 68cfcbe00..f19238606 100644
--- a/libcutils/fs_config.c
+++ b/libcutils/fs_config.c
@@ -143,7 +143,8 @@ static const struct fs_path_config android_files[] = {
     { 00700, AID_SYSTEM,    AID_SHELL,     CAP_MASK_LONG(CAP_BLOCK_SUSPEND), "system/bin/inputflinger" },
 
     /* Support FIFO scheduling mode in SurfaceFlinger. */
-    { 00755, AID_SYSTEM,    AID_GRAPHICS,     CAP_MASK_LONG(CAP_SYS_NICE), "system/bin/surfaceflinger" },
+    /* Disabled for now as this caused LD_PRELOAD and LD_SHIM_LIBS to be sanitized in linker */
+    //{ 00755, AID_SYSTEM,    AID_GRAPHICS,     CAP_MASK_LONG(CAP_SYS_NICE), "system/bin/surfaceflinger" },
 
     { 00750, AID_ROOT,      AID_ROOT,      0, "system/bin/uncrypt" },
     { 00750, AID_ROOT,      AID_ROOT,      0, "system/bin/install-recovery.sh" },
-- 
2.11.0

From fed3a8f8122ad4195a82cfeb5fe055cd79d920ae Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Wed, 23 Mar 2016 23:03:24 +0800
Subject: [PATCH] libnetutils: add MTK bits in ifc_utils.c

Change-Id: I82f04b26feaaa3dfd14e1cceffbc116b4cef093a
---
 include/netutils/ifc.h  |  15 +++
 libnetutils/ifc_utils.c | 270 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 285 insertions(+)

diff --git a/include/netutils/ifc.h b/include/netutils/ifc.h
index 3b272343d..a9a39eb70 100644
--- a/include/netutils/ifc.h
+++ b/include/netutils/ifc.h
@@ -61,6 +61,21 @@ extern int ifc_configure(const char *ifname, in_addr_t address,
 
 extern in_addr_t prefixLengthToIpv4Netmask(int prefix_length);
 
+#ifdef MTK_HARDWARE
+extern int ifc_is_up(const char *name, unsigned *isup);
+extern int ifc_enable_allmc(const char *name);
+extern int ifc_disable_allmc(const char *name);
+extern int ifc_reset_connection_by_uid(int uid, int error);
+extern int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps);
+extern int ifc_set_fwmark_rule(const char *ifname, int mark, int add);
+extern int ifc_set_txq_state(const char *ifname, int state);
+extern int ifc_ccmni_md_cfg(const char *ifname, int md_id);
+struct uid_err {
+    int appuid;
+	int errorNum;
+};
+#endif
+
 __END_DECLS
 
 #endif /* _NETUTILS_IFC_H_ */
diff --git a/libnetutils/ifc_utils.c b/libnetutils/ifc_utils.c
index 7739cf459..713091498 100644
--- a/libnetutils/ifc_utils.c
+++ b/libnetutils/ifc_utils.c
@@ -38,6 +38,10 @@
 #include <linux/rtnetlink.h>
 #include <linux/sockios.h>
 
+#ifdef MTK_HARDWARE
+#include <linux/un.h>
+#endif
+
 #include "netutils/ifc.h"
 
 #ifdef ANDROID
@@ -54,6 +58,10 @@
 #if defined(__ANDROID__)
 /* SIOCKILLADDR is an Android extension. */
 #define SIOCKILLADDR 0x8939
+
+#ifdef MTK_HARDWARE
+#define SIOCKILLSOCK 0x893a
+#endif
 #endif
 
 static int ifc_ctl_sock = -1;
@@ -737,3 +745,265 @@ ifc_configure(const char *ifname,
 
     return 0;
 }
+
+#ifdef MTK_HARDWARE
+
+#ifdef HAVE_ANDROID_OS
+int ifc_reset_connection_by_uid(int uid, int error)
+#else
+int ifc_reset_connection_by_uid(int uid __unused, int error __unused)
+#endif
+{
+
+#ifdef HAVE_ANDROID_OS
+    int tcp_ctl_sock;
+    int result = -1;
+    struct uid_err uid_e;
+
+    uid_e.appuid = uid;
+    uid_e.errorNum = error;
+
+    tcp_ctl_sock = socket(AF_INET, SOCK_STREAM, 0);
+    if (tcp_ctl_sock < 0) {
+        printerr("socket() failed: %s\n", strerror(errno));
+        return -1;
+    }
+
+    if(uid_e.appuid < 0){
+        ALOGE("ifc_reset_connection_by_uid, invalide uid: %d", uid_e.appuid);
+        close(tcp_ctl_sock);
+        return -1;
+    }
+
+    ALOGD("ifc_reset_connection_by_uid, appuid = %d, error = %d ",
+              uid_e.appuid, uid_e.errorNum);
+    result = ioctl(tcp_ctl_sock, SIOCKILLSOCK, &uid_e);
+    if(result < 0)
+        ALOGE("ifc_reset_connection_by_uid, result= %d, error =%s ", result, strerror(errno));
+
+        close(tcp_ctl_sock);
+    ALOGD("ifc_reset_connection_by_uid, result= %d ",result);
+    return result;
+#else
+    return 0;
+#endif
+}
+
+int ifc_enable_allmc(const char *ifname)
+{
+    int result;
+
+    ifc_init();
+    result = ifc_set_flags(ifname, IFF_ALLMULTI, 0);
+    ifc_close();
+
+    ALOGD("ifc_enable_allmc(%s) = %d", ifname, result);
+    return result;
+}
+
+int ifc_disable_allmc(const char *ifname)
+{
+    int result;
+
+    ifc_init();
+    result = ifc_set_flags(ifname, 0, IFF_ALLMULTI);
+    ifc_close();
+
+    ALOGD("ifc_disable_allmc(%s) = %d", ifname, result);
+    return result;
+}
+int ifc_is_up(const char *name, unsigned *isup)
+{
+    struct ifreq ifr;
+    ifc_init_ifr(name, &ifr);
+
+    if(ioctl(ifc_ctl_sock, SIOCGIFFLAGS, &ifr) < 0) {
+        printerr("ifc_is_up get flags error:%d(%s)", errno, strerror(errno));
+        return -1;
+    }
+    if(ifr.ifr_flags & IFF_UP)
+        *isup = 1;
+    else
+        *isup = 0;
+
+    return 0;
+}
+
+static int ifc_netd_sock_init(void)
+{
+    int ifc_netd_sock;
+    const int one = 1;
+    struct sockaddr_un netd_addr;
+
+        ifc_netd_sock = socket(AF_UNIX, SOCK_STREAM, 0);
+        if (ifc_netd_sock < 0) {
+            printerr("ifc_netd_sock_init: create socket failed");
+            return -1;
+        }
+
+        setsockopt(ifc_netd_sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
+        memset(&netd_addr, 0, sizeof(netd_addr));
+        netd_addr.sun_family = AF_UNIX;
+        strlcpy(netd_addr.sun_path, "/dev/socket/netd",
+            sizeof(netd_addr.sun_path));
+        if (TEMP_FAILURE_RETRY(connect(ifc_netd_sock,
+                     (const struct sockaddr*) &netd_addr,
+                     sizeof(netd_addr))) != 0) {
+            printerr("ifc_netd_sock_init: connect to netd failed, fd=%d, err: %d(%s)",
+                ifc_netd_sock, errno, strerror(errno));
+            close(ifc_netd_sock);
+            return -1;
+        }
+
+    if (DBG) printerr("ifc_netd_sock_init fd=%d", ifc_netd_sock);
+    return ifc_netd_sock;
+}
+
+/*do not call this function in netd*/
+int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 1;
+    char rcv_buf[24];
+    int nread = 0;
+    int netd_sock = 0;
+
+    ALOGD("enter ifc_set_throttle: ifname = %s, rx = %d kbs, tx = %d kbs", ifname, rxKbps, txKbps);
+
+    netd_sock = ifc_netd_sock_init();
+    if(netd_sock <= 0)
+        goto exit;
+
+    // Send the request.
+    fnetd = fdopen(netd_sock, "r+");
+    if(fnetd == NULL){
+        ALOGE("open netd socket failed, err:%d(%s)", errno, strerror(errno));
+        goto exit;
+    }
+    if (fprintf(fnetd, "%d interface setthrottle %s %d %d", seq, ifname, rxKbps, txKbps) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+    //Todo: read the whole response from netd
+    nread = fread(rcv_buf, 1, 20, fnetd);
+    rcv_buf[23] = 0;
+    ALOGD("response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+    return ret;
+}
+
+/*do not call this function in netd*/
+int ifc_set_fwmark_rule(const char *ifname, int mark, int add)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 2;
+    char rcv_buf[24];
+      int nread = 0;
+      const char* op;
+    int netd_sock = 0;
+
+    if (add) {
+        op = "add";
+    } else {
+        op = "remove";
+    }
+    ALOGD("enter ifc_set_fwmark_rule: ifname = %s, mark = %d, op = %s", ifname, mark, op);
+
+    netd_sock = ifc_netd_sock_init();
+    if(netd_sock <= 0)
+        goto exit;
+
+    // Send the request.
+    fnetd = fdopen(netd_sock, "r+");
+    if(fnetd == NULL){
+        ALOGE("open netd socket failed, err:%d(%s)", errno, strerror(errno));
+        goto exit;
+    }
+    if (fprintf(fnetd, "%d network fwmark %s %s %d", seq, op, ifname, mark) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+    //Todo: read the whole response from netd
+    nread = fread(rcv_buf, 1, 20, fnetd);
+    rcv_buf[23] = 0;
+    ALOGD("ifc_set_fwmark_rule response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+    return ret;
+}
+
+#define SIOCSTXQSTATE (SIOCDEVPRIVATE + 0)  //start/stop ccmni tx queue
+#define SIOCSCCMNICFG (SIOCDEVPRIVATE + 1)  //configure ccmni/md remapping
+
+int ifc_set_txq_state(const char *ifname, int state)
+{
+    struct ifreq ifr;
+    int ret, ctl_sock;
+
+    memset(&ifr, 0, sizeof(struct ifreq));
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+    ifr.ifr_name[IFNAMSIZ - 1] = 0;
+    ifr.ifr_ifru.ifru_ivalue = state;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+        ALOGE("create ctl socket failed\n");
+        return -1;
+    }
+    ret = ioctl(ctl_sock, SIOCSTXQSTATE, &ifr);
+    if(ret < 0)
+        ALOGE("ifc_set_txq_state failed, err:%d(%s)\n", errno, strerror(errno));
+    else
+        ALOGI("ifc_set_txq_state as %d, ret: %d\n", state, ret);
+
+    close(ctl_sock);
+
+    return ret;
+}
+
+int ifc_ccmni_md_cfg(const char *ifname, int md_id)
+{
+    struct ifreq ifr;
+    int ret = 0;
+    int ctl_sock = 0;
+
+    ifc_init_ifr(ifname, &ifr);
+    ifr.ifr_ifru.ifru_ivalue = md_id;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+        printerr("ifc_ccmni_md_cfg: create ctl socket failed\n");
+        return -1;
+    }
+
+    if(ioctl(ctl_sock, SIOCSCCMNICFG, &ifr) < 0) {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) error:%d(%s)", \
+            ifname, md_id, errno, strerror(errno));
+        ret = -1;
+    } else {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) OK", ifname, md_id);
+    }
+
+    close(ctl_sock);
+    return ret;
+}
+#endif
-- 
2.11.0

From b735ab9e276a0911dce01c1516b7ed3ef02675ed Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Thu, 24 Mar 2016 01:55:24 +0800
Subject: [PATCH] init: double the number of available environment variables

[Ported to N by @xen0n.]

Change-Id: Ie831be3e0ed907ef77d69cf47572088666bddf78

Conflicts:
	init/init.cpp
---
 init/init.cpp | 4 +++-
 init/init.h   | 2 +-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/init/init.cpp b/init/init.cpp
index e9da9586d..c40b86148 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -85,7 +85,9 @@ int have_console;
 std::string console_name = "/dev/console";
 static time_t process_needs_restart;
 
-const char *ENV[32];
+// xen0n: some MTK services (e.g. ril-daemon-mtk) require very large number
+// of sockets, which can't be contained in 32 entries minus other variables.
+const char *ENV[64];
 
 bool waiting_for_exec = false;
 
diff --git a/init/init.h b/init/init.h
index 345d442c0..f93d0c5ba 100644
--- a/init/init.h
+++ b/init/init.h
@@ -24,7 +24,7 @@ class Service;
 
 #define COMMAND_RETRY_TIMEOUT 5
 
-extern const char *ENV[32];
+extern const char *ENV[64];
 extern bool waiting_for_exec;
 extern int have_console;
 extern std::string console_name;
-- 
2.11.0

From 0b86530f2da391a7821e089e1f1e85b51f6cca44 Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Tue, 29 Sep 2015 13:16:33 +0800
Subject: [PATCH] healthd: correctly report battery voltage on MTK kernels

Change-Id: I0d183d028ec28a41d0c87f2e496863e5991013d2
---
 healthd/BatteryMonitor.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/healthd/BatteryMonitor.cpp b/healthd/BatteryMonitor.cpp
index d2088eefb..947e83efd 100644
--- a/healthd/BatteryMonitor.cpp
+++ b/healthd/BatteryMonitor.cpp
@@ -228,7 +228,11 @@ bool BatteryMonitor::update(void) {
     props.batteryLevel = mBatteryFixedCapacity ?
         mBatteryFixedCapacity :
         getIntField(mHealthdConfig->batteryCapacityPath);
+#ifndef MTK_HARDWARE
     props.batteryVoltage = getIntField(mHealthdConfig->batteryVoltagePath) / 1000;
+#else
+    props.batteryVoltage = getIntField(mHealthdConfig->batteryVoltagePath);
+#endif
 
     if (!mHealthdConfig->batteryCurrentNowPath.isEmpty())
         props.batteryCurrent = getIntField(mHealthdConfig->batteryCurrentNowPath) / 1000;
-- 
2.11.0

From d41237b082b098f934a06de382f37e05b0890107 Mon Sep 17 00:00:00 2001
From: Adriano Martins <adrianomartins@gmail.com>
Date: Tue, 13 Dec 2016 21:45:27 -0200
Subject: [PATCH] Default to MTK

Change-Id: I56e4b26d4f23e9a6604ea7798accf48adcac5d77
---
 healthd/BatteryMonitor.cpp | 4 ----
 include/netutils/ifc.h     | 2 --
 libnetutils/ifc_utils.c    | 6 ------
 3 files changed, 12 deletions(-)

diff --git a/healthd/BatteryMonitor.cpp b/healthd/BatteryMonitor.cpp
index 947e83efd..d2088eefb 100644
--- a/healthd/BatteryMonitor.cpp
+++ b/healthd/BatteryMonitor.cpp
@@ -228,11 +228,7 @@ bool BatteryMonitor::update(void) {
     props.batteryLevel = mBatteryFixedCapacity ?
         mBatteryFixedCapacity :
         getIntField(mHealthdConfig->batteryCapacityPath);
-#ifndef MTK_HARDWARE
     props.batteryVoltage = getIntField(mHealthdConfig->batteryVoltagePath) / 1000;
-#else
-    props.batteryVoltage = getIntField(mHealthdConfig->batteryVoltagePath);
-#endif
 
     if (!mHealthdConfig->batteryCurrentNowPath.isEmpty())
         props.batteryCurrent = getIntField(mHealthdConfig->batteryCurrentNowPath) / 1000;
diff --git a/include/netutils/ifc.h b/include/netutils/ifc.h
index a9a39eb70..e6deaa64c 100644
--- a/include/netutils/ifc.h
+++ b/include/netutils/ifc.h
@@ -61,7 +61,6 @@ extern int ifc_configure(const char *ifname, in_addr_t address,
 
 extern in_addr_t prefixLengthToIpv4Netmask(int prefix_length);
 
-#ifdef MTK_HARDWARE
 extern int ifc_is_up(const char *name, unsigned *isup);
 extern int ifc_enable_allmc(const char *name);
 extern int ifc_disable_allmc(const char *name);
@@ -74,7 +73,6 @@ struct uid_err {
     int appuid;
 	int errorNum;
 };
-#endif
 
 __END_DECLS
 
diff --git a/libnetutils/ifc_utils.c b/libnetutils/ifc_utils.c
index 713091498..888945ae9 100644
--- a/libnetutils/ifc_utils.c
+++ b/libnetutils/ifc_utils.c
@@ -38,9 +38,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/sockios.h>
 
-#ifdef MTK_HARDWARE
 #include <linux/un.h>
-#endif
 
 #include "netutils/ifc.h"
 
@@ -59,10 +57,8 @@
 /* SIOCKILLADDR is an Android extension. */
 #define SIOCKILLADDR 0x8939
 
-#ifdef MTK_HARDWARE
 #define SIOCKILLSOCK 0x893a
 #endif
-#endif
 
 static int ifc_ctl_sock = -1;
 static int ifc_ctl_sock6 = -1;
@@ -746,7 +742,6 @@ ifc_configure(const char *ifname,
     return 0;
 }
 
-#ifdef MTK_HARDWARE
 
 #ifdef HAVE_ANDROID_OS
 int ifc_reset_connection_by_uid(int uid, int error)
@@ -1006,4 +1001,3 @@ int ifc_ccmni_md_cfg(const char *ifname, int md_id)
     close(ctl_sock);
     return ret;
 }
-#endif
-- 
2.11.0

